# Phone Address API

Тестовое задание лёгкое FastAPI-приложение для хранения/получения адреса по телефонному номеру.

## Кратко
- API endpoint prefix: по умолчанию `/addr_by_phone` (можно изменить через переменную `ENDPOINT_PREFIX`)
- Хранилище: Redis (ключ — телефон в RFC3966, значение — строка адреса)

## Переменные окружения
Приложение конфигурируется через переменные окружения (можно положить в файл `.env`):

- `REDIS_HOST` — адрес Redis (по умолчанию `localhost`)
- `REDIS_PORT` — порт Redis (по умолчанию `6379`)
- `REDIS_USERNAME` — имя пользователя (по умолчанию `default`)
- `REDIS_PASSWORD` — пароль (по умолчанию `changeme123`)
- `REDIS_DB` — номер БД (по умолчанию `0`)
- `ENDPOINT_PREFIX` — префикс для endpoint'ов (по умолчанию `/addr_by_phone`)

## Локальная разработка
1. Создайте и активируйте виртуальное окружение (пример для bash):

```bash
python -m venv .venv
source .venv/bin/activate
```

2. Установите зависимости:

```bash
pip install -r requirements.txt
```

3. Создайте `.env` можно воспользоваться env.example (или экспортируйте переменные окружения), затем запустите сервер для разработки:

```bash
uvicorn main:app --reload --host 0.0.0.0 --port 8000
```

4. Откройте документацию: http://localhost:8000/docs

## Запуск в Docker


### Запуск контейнера

```bash
# создал .env в корне
docker run --env-file .env -p 8000:8000 --name phone_address_api phone_addr_api
```

Или через `docker-compose` (рекомендуется для локальной разработки с Redis):

```bash
docker compose up --build -d
```

Файл `docker-compose.yaml` уже содержит сервисы: `redis`, `app` и опциональный `redis-commander`.

для запуска без redis-commander
```bash
docker compose up app redis --build -d
```

## Тесты
Запуск тестов:

```bash
pytest -q
```

## Горизонтальное масштабирование
Данное тестовное задание было написано с прицелом на возможность горизотально масштабировать

- Приложение спроектировано как stateless (все состояния хранятся в Redis). Это значит, что несколько экземляров приложения могут обслуживать запросы параллельно — нет необходимости в синхронизации внутреннего состояния между ними.

- На уровне контейнеров/VM можно использовать балансировщики NGINX, Traefik или haproxy для распределения трафика между репликами.
- В контейнерных кластерах (Docker Swarm, Kubernetes) можно использовать встроенные механизмы сервисов/Ingress для балансировки.

- Redis — это основное хранилище: он должен быть доступен и устойчив к сбоям.
Для простого окружения: Redis Sentinel один инстанс Redis который может писать + реплики для чтения. 
также будет доступно автоматическое переключение мастера при падении.

Для масштабирования записи и крупных объёмов данных лучше использовать Redis Cluster — он шардует ключи по нескольким нодам.



## Замечания о текущем Dockerfile
- В текущем Dockerfile используется пользователь `fastapi` так чуть более секьюрно.
- В `Dockerfile` используется `python:3.12-alpine3.22`.
Дистр alpine3.22 выбран как общая база для python и redis, чтобы уменишить итоговый размер контейнеров.
Минусы такого решения в том что alpine3.22 иногда вызывает сложности с компиляцией бинарных зависимостей (wheels).



